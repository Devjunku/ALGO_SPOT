import sys
input = sys.stdin.readline

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]

INF = sys.maxsize
dp = [INF for _ in range(1 << n)]
dp[0] = 0

for i in range(1 << n):

    bit = i
    num = 0

    while bit != 0:
        num += (bit & 1)
        bit >>= 1    

    for j in range(n):
        if not i & (1 << j):
            dp[i | (1 << j)] = min(dp[i | (1 << j)], dp[i] + arr[num][j])

print(dp[-1])

"""
모든 일을 하는 데 필요한 최소 비용

조건 1: 모든 일을 무조건 해야 된다.

조건 2: 입력값이 20이라 크지 않을 수도 있지만, 이는 매우 큰 값이다. 20**20까지 갈 수 있다.

따라서 dynimic으로 최소값을 계속 표현하면서 연산을 줄여야 한다.
문제의 데이터 형식은 1번째 사람이 j번째 일을 했을 때의 비용이다.

그렇다면 어떤 특정 상태에서 그 다음의 상태의 비용을 비교했을 때 둘 중 더 작은 애를 집어 넣으면 된다.
중요한 것은 그리디로 풀 수가 없다. 20**20은 너무 큰 수이며
시간초과를 방지하기 위해서는 먼저 어떤 비트를 갖고 있다고 가정한다.

왜냐하면, 비트를 통해 1 << n까지 모두 순회하며
초기 어떤 일이 진행되고 있는지 체크할 것이다.
여기서 중요한 것은 어떤 일을 누가 지금 하고 있다는 것이 중요하다.
따라서 한번의 순회(현재 어떤 작업이 진행중인지)에서 다음 상태만을 업데이트 한다.
그 상태만 기억했다가 그 다음 상태의 최소값만 업데이트 해놓는 상태
따라서 현재 몇명이 어떤 일을 하고 있는지가 중요해진다.
1이면 일하는 상태 그렇지 않으면 일하지 않는 상태

중요한건 이거 헝가리안 알고리즘이라는 것으로 O(n^3)으로 빠르게 문제를 풀 수 있다고 한다.
8000...???!!!!
"""